// Code generated by entc, DO NOT EDIT.

package dbpackage

import (
	"time"

	"ALHP.go/ent/predicate"
	"entgo.io/ent/dialect/sql"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// Pkgbase applies equality check predicate on the "pkgbase" field. It's identical to PkgbaseEQ.
func Pkgbase(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPkgbase), v))
	})
}

// Status applies equality check predicate on the "status" field. It's identical to StatusEQ.
func Status(v int) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStatus), v))
	})
}

// SkipReason applies equality check predicate on the "skip_reason" field. It's identical to SkipReasonEQ.
func SkipReason(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSkipReason), v))
	})
}

// Repository applies equality check predicate on the "repository" field. It's identical to RepositoryEQ.
func Repository(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRepository), v))
	})
}

// March applies equality check predicate on the "march" field. It's identical to MarchEQ.
func March(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMarch), v))
	})
}

// Version applies equality check predicate on the "version" field. It's identical to VersionEQ.
func Version(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldVersion), v))
	})
}

// RepoVersion applies equality check predicate on the "repo_version" field. It's identical to RepoVersionEQ.
func RepoVersion(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRepoVersion), v))
	})
}

// BuildTime applies equality check predicate on the "build_time" field. It's identical to BuildTimeEQ.
func BuildTime(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBuildTime), v))
	})
}

// BuildDuration applies equality check predicate on the "build_duration" field. It's identical to BuildDurationEQ.
func BuildDuration(v uint64) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBuildDuration), v))
	})
}

// Updated applies equality check predicate on the "updated" field. It's identical to UpdatedEQ.
func Updated(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdated), v))
	})
}

// Hash applies equality check predicate on the "hash" field. It's identical to HashEQ.
func Hash(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldHash), v))
	})
}

// PkgbaseEQ applies the EQ predicate on the "pkgbase" field.
func PkgbaseEQ(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPkgbase), v))
	})
}

// PkgbaseNEQ applies the NEQ predicate on the "pkgbase" field.
func PkgbaseNEQ(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPkgbase), v))
	})
}

// PkgbaseIn applies the In predicate on the "pkgbase" field.
func PkgbaseIn(vs ...string) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPkgbase), v...))
	})
}

// PkgbaseNotIn applies the NotIn predicate on the "pkgbase" field.
func PkgbaseNotIn(vs ...string) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPkgbase), v...))
	})
}

// PkgbaseGT applies the GT predicate on the "pkgbase" field.
func PkgbaseGT(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPkgbase), v))
	})
}

// PkgbaseGTE applies the GTE predicate on the "pkgbase" field.
func PkgbaseGTE(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPkgbase), v))
	})
}

// PkgbaseLT applies the LT predicate on the "pkgbase" field.
func PkgbaseLT(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPkgbase), v))
	})
}

// PkgbaseLTE applies the LTE predicate on the "pkgbase" field.
func PkgbaseLTE(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPkgbase), v))
	})
}

// PkgbaseContains applies the Contains predicate on the "pkgbase" field.
func PkgbaseContains(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldPkgbase), v))
	})
}

// PkgbaseHasPrefix applies the HasPrefix predicate on the "pkgbase" field.
func PkgbaseHasPrefix(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldPkgbase), v))
	})
}

// PkgbaseHasSuffix applies the HasSuffix predicate on the "pkgbase" field.
func PkgbaseHasSuffix(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldPkgbase), v))
	})
}

// PkgbaseEqualFold applies the EqualFold predicate on the "pkgbase" field.
func PkgbaseEqualFold(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldPkgbase), v))
	})
}

// PkgbaseContainsFold applies the ContainsFold predicate on the "pkgbase" field.
func PkgbaseContainsFold(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldPkgbase), v))
	})
}

// PackagesIsNil applies the IsNil predicate on the "packages" field.
func PackagesIsNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPackages)))
	})
}

// PackagesNotNil applies the NotNil predicate on the "packages" field.
func PackagesNotNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPackages)))
	})
}

// StatusEQ applies the EQ predicate on the "status" field.
func StatusEQ(v int) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStatus), v))
	})
}

// StatusNEQ applies the NEQ predicate on the "status" field.
func StatusNEQ(v int) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldStatus), v))
	})
}

// StatusIn applies the In predicate on the "status" field.
func StatusIn(vs ...int) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldStatus), v...))
	})
}

// StatusNotIn applies the NotIn predicate on the "status" field.
func StatusNotIn(vs ...int) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldStatus), v...))
	})
}

// StatusGT applies the GT predicate on the "status" field.
func StatusGT(v int) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldStatus), v))
	})
}

// StatusGTE applies the GTE predicate on the "status" field.
func StatusGTE(v int) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldStatus), v))
	})
}

// StatusLT applies the LT predicate on the "status" field.
func StatusLT(v int) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldStatus), v))
	})
}

// StatusLTE applies the LTE predicate on the "status" field.
func StatusLTE(v int) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldStatus), v))
	})
}

// SkipReasonEQ applies the EQ predicate on the "skip_reason" field.
func SkipReasonEQ(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSkipReason), v))
	})
}

// SkipReasonNEQ applies the NEQ predicate on the "skip_reason" field.
func SkipReasonNEQ(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSkipReason), v))
	})
}

// SkipReasonIn applies the In predicate on the "skip_reason" field.
func SkipReasonIn(vs ...string) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSkipReason), v...))
	})
}

// SkipReasonNotIn applies the NotIn predicate on the "skip_reason" field.
func SkipReasonNotIn(vs ...string) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSkipReason), v...))
	})
}

// SkipReasonGT applies the GT predicate on the "skip_reason" field.
func SkipReasonGT(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSkipReason), v))
	})
}

// SkipReasonGTE applies the GTE predicate on the "skip_reason" field.
func SkipReasonGTE(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSkipReason), v))
	})
}

// SkipReasonLT applies the LT predicate on the "skip_reason" field.
func SkipReasonLT(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSkipReason), v))
	})
}

// SkipReasonLTE applies the LTE predicate on the "skip_reason" field.
func SkipReasonLTE(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSkipReason), v))
	})
}

// SkipReasonContains applies the Contains predicate on the "skip_reason" field.
func SkipReasonContains(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldSkipReason), v))
	})
}

// SkipReasonHasPrefix applies the HasPrefix predicate on the "skip_reason" field.
func SkipReasonHasPrefix(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldSkipReason), v))
	})
}

// SkipReasonHasSuffix applies the HasSuffix predicate on the "skip_reason" field.
func SkipReasonHasSuffix(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldSkipReason), v))
	})
}

// SkipReasonIsNil applies the IsNil predicate on the "skip_reason" field.
func SkipReasonIsNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldSkipReason)))
	})
}

// SkipReasonNotNil applies the NotNil predicate on the "skip_reason" field.
func SkipReasonNotNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldSkipReason)))
	})
}

// SkipReasonEqualFold applies the EqualFold predicate on the "skip_reason" field.
func SkipReasonEqualFold(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldSkipReason), v))
	})
}

// SkipReasonContainsFold applies the ContainsFold predicate on the "skip_reason" field.
func SkipReasonContainsFold(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldSkipReason), v))
	})
}

// RepositoryEQ applies the EQ predicate on the "repository" field.
func RepositoryEQ(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRepository), v))
	})
}

// RepositoryNEQ applies the NEQ predicate on the "repository" field.
func RepositoryNEQ(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRepository), v))
	})
}

// RepositoryIn applies the In predicate on the "repository" field.
func RepositoryIn(vs ...string) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldRepository), v...))
	})
}

// RepositoryNotIn applies the NotIn predicate on the "repository" field.
func RepositoryNotIn(vs ...string) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldRepository), v...))
	})
}

// RepositoryGT applies the GT predicate on the "repository" field.
func RepositoryGT(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldRepository), v))
	})
}

// RepositoryGTE applies the GTE predicate on the "repository" field.
func RepositoryGTE(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldRepository), v))
	})
}

// RepositoryLT applies the LT predicate on the "repository" field.
func RepositoryLT(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldRepository), v))
	})
}

// RepositoryLTE applies the LTE predicate on the "repository" field.
func RepositoryLTE(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldRepository), v))
	})
}

// RepositoryContains applies the Contains predicate on the "repository" field.
func RepositoryContains(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldRepository), v))
	})
}

// RepositoryHasPrefix applies the HasPrefix predicate on the "repository" field.
func RepositoryHasPrefix(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldRepository), v))
	})
}

// RepositoryHasSuffix applies the HasSuffix predicate on the "repository" field.
func RepositoryHasSuffix(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldRepository), v))
	})
}

// RepositoryEqualFold applies the EqualFold predicate on the "repository" field.
func RepositoryEqualFold(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldRepository), v))
	})
}

// RepositoryContainsFold applies the ContainsFold predicate on the "repository" field.
func RepositoryContainsFold(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldRepository), v))
	})
}

// MarchEQ applies the EQ predicate on the "march" field.
func MarchEQ(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMarch), v))
	})
}

// MarchNEQ applies the NEQ predicate on the "march" field.
func MarchNEQ(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldMarch), v))
	})
}

// MarchIn applies the In predicate on the "march" field.
func MarchIn(vs ...string) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldMarch), v...))
	})
}

// MarchNotIn applies the NotIn predicate on the "march" field.
func MarchNotIn(vs ...string) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldMarch), v...))
	})
}

// MarchGT applies the GT predicate on the "march" field.
func MarchGT(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldMarch), v))
	})
}

// MarchGTE applies the GTE predicate on the "march" field.
func MarchGTE(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldMarch), v))
	})
}

// MarchLT applies the LT predicate on the "march" field.
func MarchLT(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldMarch), v))
	})
}

// MarchLTE applies the LTE predicate on the "march" field.
func MarchLTE(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldMarch), v))
	})
}

// MarchContains applies the Contains predicate on the "march" field.
func MarchContains(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldMarch), v))
	})
}

// MarchHasPrefix applies the HasPrefix predicate on the "march" field.
func MarchHasPrefix(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldMarch), v))
	})
}

// MarchHasSuffix applies the HasSuffix predicate on the "march" field.
func MarchHasSuffix(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldMarch), v))
	})
}

// MarchEqualFold applies the EqualFold predicate on the "march" field.
func MarchEqualFold(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldMarch), v))
	})
}

// MarchContainsFold applies the ContainsFold predicate on the "march" field.
func MarchContainsFold(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldMarch), v))
	})
}

// VersionEQ applies the EQ predicate on the "version" field.
func VersionEQ(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldVersion), v))
	})
}

// VersionNEQ applies the NEQ predicate on the "version" field.
func VersionNEQ(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldVersion), v))
	})
}

// VersionIn applies the In predicate on the "version" field.
func VersionIn(vs ...string) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldVersion), v...))
	})
}

// VersionNotIn applies the NotIn predicate on the "version" field.
func VersionNotIn(vs ...string) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldVersion), v...))
	})
}

// VersionGT applies the GT predicate on the "version" field.
func VersionGT(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldVersion), v))
	})
}

// VersionGTE applies the GTE predicate on the "version" field.
func VersionGTE(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldVersion), v))
	})
}

// VersionLT applies the LT predicate on the "version" field.
func VersionLT(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldVersion), v))
	})
}

// VersionLTE applies the LTE predicate on the "version" field.
func VersionLTE(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldVersion), v))
	})
}

// VersionContains applies the Contains predicate on the "version" field.
func VersionContains(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldVersion), v))
	})
}

// VersionHasPrefix applies the HasPrefix predicate on the "version" field.
func VersionHasPrefix(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldVersion), v))
	})
}

// VersionHasSuffix applies the HasSuffix predicate on the "version" field.
func VersionHasSuffix(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldVersion), v))
	})
}

// VersionIsNil applies the IsNil predicate on the "version" field.
func VersionIsNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldVersion)))
	})
}

// VersionNotNil applies the NotNil predicate on the "version" field.
func VersionNotNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldVersion)))
	})
}

// VersionEqualFold applies the EqualFold predicate on the "version" field.
func VersionEqualFold(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldVersion), v))
	})
}

// VersionContainsFold applies the ContainsFold predicate on the "version" field.
func VersionContainsFold(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldVersion), v))
	})
}

// RepoVersionEQ applies the EQ predicate on the "repo_version" field.
func RepoVersionEQ(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRepoVersion), v))
	})
}

// RepoVersionNEQ applies the NEQ predicate on the "repo_version" field.
func RepoVersionNEQ(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRepoVersion), v))
	})
}

// RepoVersionIn applies the In predicate on the "repo_version" field.
func RepoVersionIn(vs ...string) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldRepoVersion), v...))
	})
}

// RepoVersionNotIn applies the NotIn predicate on the "repo_version" field.
func RepoVersionNotIn(vs ...string) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldRepoVersion), v...))
	})
}

// RepoVersionGT applies the GT predicate on the "repo_version" field.
func RepoVersionGT(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldRepoVersion), v))
	})
}

// RepoVersionGTE applies the GTE predicate on the "repo_version" field.
func RepoVersionGTE(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldRepoVersion), v))
	})
}

// RepoVersionLT applies the LT predicate on the "repo_version" field.
func RepoVersionLT(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldRepoVersion), v))
	})
}

// RepoVersionLTE applies the LTE predicate on the "repo_version" field.
func RepoVersionLTE(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldRepoVersion), v))
	})
}

// RepoVersionContains applies the Contains predicate on the "repo_version" field.
func RepoVersionContains(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldRepoVersion), v))
	})
}

// RepoVersionHasPrefix applies the HasPrefix predicate on the "repo_version" field.
func RepoVersionHasPrefix(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldRepoVersion), v))
	})
}

// RepoVersionHasSuffix applies the HasSuffix predicate on the "repo_version" field.
func RepoVersionHasSuffix(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldRepoVersion), v))
	})
}

// RepoVersionIsNil applies the IsNil predicate on the "repo_version" field.
func RepoVersionIsNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldRepoVersion)))
	})
}

// RepoVersionNotNil applies the NotNil predicate on the "repo_version" field.
func RepoVersionNotNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldRepoVersion)))
	})
}

// RepoVersionEqualFold applies the EqualFold predicate on the "repo_version" field.
func RepoVersionEqualFold(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldRepoVersion), v))
	})
}

// RepoVersionContainsFold applies the ContainsFold predicate on the "repo_version" field.
func RepoVersionContainsFold(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldRepoVersion), v))
	})
}

// BuildTimeEQ applies the EQ predicate on the "build_time" field.
func BuildTimeEQ(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBuildTime), v))
	})
}

// BuildTimeNEQ applies the NEQ predicate on the "build_time" field.
func BuildTimeNEQ(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldBuildTime), v))
	})
}

// BuildTimeIn applies the In predicate on the "build_time" field.
func BuildTimeIn(vs ...time.Time) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldBuildTime), v...))
	})
}

// BuildTimeNotIn applies the NotIn predicate on the "build_time" field.
func BuildTimeNotIn(vs ...time.Time) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldBuildTime), v...))
	})
}

// BuildTimeGT applies the GT predicate on the "build_time" field.
func BuildTimeGT(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldBuildTime), v))
	})
}

// BuildTimeGTE applies the GTE predicate on the "build_time" field.
func BuildTimeGTE(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldBuildTime), v))
	})
}

// BuildTimeLT applies the LT predicate on the "build_time" field.
func BuildTimeLT(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldBuildTime), v))
	})
}

// BuildTimeLTE applies the LTE predicate on the "build_time" field.
func BuildTimeLTE(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldBuildTime), v))
	})
}

// BuildTimeIsNil applies the IsNil predicate on the "build_time" field.
func BuildTimeIsNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldBuildTime)))
	})
}

// BuildTimeNotNil applies the NotNil predicate on the "build_time" field.
func BuildTimeNotNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldBuildTime)))
	})
}

// BuildDurationEQ applies the EQ predicate on the "build_duration" field.
func BuildDurationEQ(v uint64) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBuildDuration), v))
	})
}

// BuildDurationNEQ applies the NEQ predicate on the "build_duration" field.
func BuildDurationNEQ(v uint64) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldBuildDuration), v))
	})
}

// BuildDurationIn applies the In predicate on the "build_duration" field.
func BuildDurationIn(vs ...uint64) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldBuildDuration), v...))
	})
}

// BuildDurationNotIn applies the NotIn predicate on the "build_duration" field.
func BuildDurationNotIn(vs ...uint64) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldBuildDuration), v...))
	})
}

// BuildDurationGT applies the GT predicate on the "build_duration" field.
func BuildDurationGT(v uint64) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldBuildDuration), v))
	})
}

// BuildDurationGTE applies the GTE predicate on the "build_duration" field.
func BuildDurationGTE(v uint64) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldBuildDuration), v))
	})
}

// BuildDurationLT applies the LT predicate on the "build_duration" field.
func BuildDurationLT(v uint64) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldBuildDuration), v))
	})
}

// BuildDurationLTE applies the LTE predicate on the "build_duration" field.
func BuildDurationLTE(v uint64) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldBuildDuration), v))
	})
}

// BuildDurationIsNil applies the IsNil predicate on the "build_duration" field.
func BuildDurationIsNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldBuildDuration)))
	})
}

// BuildDurationNotNil applies the NotNil predicate on the "build_duration" field.
func BuildDurationNotNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldBuildDuration)))
	})
}

// UpdatedEQ applies the EQ predicate on the "updated" field.
func UpdatedEQ(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdated), v))
	})
}

// UpdatedNEQ applies the NEQ predicate on the "updated" field.
func UpdatedNEQ(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUpdated), v))
	})
}

// UpdatedIn applies the In predicate on the "updated" field.
func UpdatedIn(vs ...time.Time) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUpdated), v...))
	})
}

// UpdatedNotIn applies the NotIn predicate on the "updated" field.
func UpdatedNotIn(vs ...time.Time) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUpdated), v...))
	})
}

// UpdatedGT applies the GT predicate on the "updated" field.
func UpdatedGT(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUpdated), v))
	})
}

// UpdatedGTE applies the GTE predicate on the "updated" field.
func UpdatedGTE(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUpdated), v))
	})
}

// UpdatedLT applies the LT predicate on the "updated" field.
func UpdatedLT(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUpdated), v))
	})
}

// UpdatedLTE applies the LTE predicate on the "updated" field.
func UpdatedLTE(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUpdated), v))
	})
}

// UpdatedIsNil applies the IsNil predicate on the "updated" field.
func UpdatedIsNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldUpdated)))
	})
}

// UpdatedNotNil applies the NotNil predicate on the "updated" field.
func UpdatedNotNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldUpdated)))
	})
}

// HashEQ applies the EQ predicate on the "hash" field.
func HashEQ(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldHash), v))
	})
}

// HashNEQ applies the NEQ predicate on the "hash" field.
func HashNEQ(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldHash), v))
	})
}

// HashIn applies the In predicate on the "hash" field.
func HashIn(vs ...string) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldHash), v...))
	})
}

// HashNotIn applies the NotIn predicate on the "hash" field.
func HashNotIn(vs ...string) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldHash), v...))
	})
}

// HashGT applies the GT predicate on the "hash" field.
func HashGT(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldHash), v))
	})
}

// HashGTE applies the GTE predicate on the "hash" field.
func HashGTE(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldHash), v))
	})
}

// HashLT applies the LT predicate on the "hash" field.
func HashLT(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldHash), v))
	})
}

// HashLTE applies the LTE predicate on the "hash" field.
func HashLTE(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldHash), v))
	})
}

// HashContains applies the Contains predicate on the "hash" field.
func HashContains(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldHash), v))
	})
}

// HashHasPrefix applies the HasPrefix predicate on the "hash" field.
func HashHasPrefix(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldHash), v))
	})
}

// HashHasSuffix applies the HasSuffix predicate on the "hash" field.
func HashHasSuffix(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldHash), v))
	})
}

// HashIsNil applies the IsNil predicate on the "hash" field.
func HashIsNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldHash)))
	})
}

// HashNotNil applies the NotNil predicate on the "hash" field.
func HashNotNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldHash)))
	})
}

// HashEqualFold applies the EqualFold predicate on the "hash" field.
func HashEqualFold(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldHash), v))
	})
}

// HashContainsFold applies the ContainsFold predicate on the "hash" field.
func HashContainsFold(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldHash), v))
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.DbPackage) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.DbPackage) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.DbPackage) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		p(s.Not())
	})
}
