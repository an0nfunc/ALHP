// Code generated by entc, DO NOT EDIT.

package dbpackage

import (
	"time"

	"entgo.io/ent/dialect/sql"
	"git.harting.dev/ALHP/ALHP.GO/ent/predicate"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// Pkgbase applies equality check predicate on the "pkgbase" field. It's identical to PkgbaseEQ.
func Pkgbase(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPkgbase), v))
	})
}

// SkipReason applies equality check predicate on the "skip_reason" field. It's identical to SkipReasonEQ.
func SkipReason(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSkipReason), v))
	})
}

// March applies equality check predicate on the "march" field. It's identical to MarchEQ.
func March(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMarch), v))
	})
}

// Version applies equality check predicate on the "version" field. It's identical to VersionEQ.
func Version(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldVersion), v))
	})
}

// RepoVersion applies equality check predicate on the "repo_version" field. It's identical to RepoVersionEQ.
func RepoVersion(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRepoVersion), v))
	})
}

// BuildTimeStart applies equality check predicate on the "build_time_start" field. It's identical to BuildTimeStartEQ.
func BuildTimeStart(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBuildTimeStart), v))
	})
}

// BuildTimeEnd applies equality check predicate on the "build_time_end" field. It's identical to BuildTimeEndEQ.
func BuildTimeEnd(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBuildTimeEnd), v))
	})
}

// Updated applies equality check predicate on the "updated" field. It's identical to UpdatedEQ.
func Updated(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdated), v))
	})
}

// Hash applies equality check predicate on the "hash" field. It's identical to HashEQ.
func Hash(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldHash), v))
	})
}

// LastVersionBuild applies equality check predicate on the "last_version_build" field. It's identical to LastVersionBuildEQ.
func LastVersionBuild(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLastVersionBuild), v))
	})
}

// LastVerified applies equality check predicate on the "last_verified" field. It's identical to LastVerifiedEQ.
func LastVerified(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLastVerified), v))
	})
}

// PkgbaseEQ applies the EQ predicate on the "pkgbase" field.
func PkgbaseEQ(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPkgbase), v))
	})
}

// PkgbaseNEQ applies the NEQ predicate on the "pkgbase" field.
func PkgbaseNEQ(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPkgbase), v))
	})
}

// PkgbaseIn applies the In predicate on the "pkgbase" field.
func PkgbaseIn(vs ...string) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPkgbase), v...))
	})
}

// PkgbaseNotIn applies the NotIn predicate on the "pkgbase" field.
func PkgbaseNotIn(vs ...string) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPkgbase), v...))
	})
}

// PkgbaseGT applies the GT predicate on the "pkgbase" field.
func PkgbaseGT(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPkgbase), v))
	})
}

// PkgbaseGTE applies the GTE predicate on the "pkgbase" field.
func PkgbaseGTE(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPkgbase), v))
	})
}

// PkgbaseLT applies the LT predicate on the "pkgbase" field.
func PkgbaseLT(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPkgbase), v))
	})
}

// PkgbaseLTE applies the LTE predicate on the "pkgbase" field.
func PkgbaseLTE(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPkgbase), v))
	})
}

// PkgbaseContains applies the Contains predicate on the "pkgbase" field.
func PkgbaseContains(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldPkgbase), v))
	})
}

// PkgbaseHasPrefix applies the HasPrefix predicate on the "pkgbase" field.
func PkgbaseHasPrefix(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldPkgbase), v))
	})
}

// PkgbaseHasSuffix applies the HasSuffix predicate on the "pkgbase" field.
func PkgbaseHasSuffix(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldPkgbase), v))
	})
}

// PkgbaseEqualFold applies the EqualFold predicate on the "pkgbase" field.
func PkgbaseEqualFold(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldPkgbase), v))
	})
}

// PkgbaseContainsFold applies the ContainsFold predicate on the "pkgbase" field.
func PkgbaseContainsFold(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldPkgbase), v))
	})
}

// PackagesIsNil applies the IsNil predicate on the "packages" field.
func PackagesIsNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPackages)))
	})
}

// PackagesNotNil applies the NotNil predicate on the "packages" field.
func PackagesNotNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPackages)))
	})
}

// StatusEQ applies the EQ predicate on the "status" field.
func StatusEQ(v Status) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStatus), v))
	})
}

// StatusNEQ applies the NEQ predicate on the "status" field.
func StatusNEQ(v Status) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldStatus), v))
	})
}

// StatusIn applies the In predicate on the "status" field.
func StatusIn(vs ...Status) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldStatus), v...))
	})
}

// StatusNotIn applies the NotIn predicate on the "status" field.
func StatusNotIn(vs ...Status) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldStatus), v...))
	})
}

// StatusIsNil applies the IsNil predicate on the "status" field.
func StatusIsNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldStatus)))
	})
}

// StatusNotNil applies the NotNil predicate on the "status" field.
func StatusNotNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldStatus)))
	})
}

// SkipReasonEQ applies the EQ predicate on the "skip_reason" field.
func SkipReasonEQ(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSkipReason), v))
	})
}

// SkipReasonNEQ applies the NEQ predicate on the "skip_reason" field.
func SkipReasonNEQ(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSkipReason), v))
	})
}

// SkipReasonIn applies the In predicate on the "skip_reason" field.
func SkipReasonIn(vs ...string) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSkipReason), v...))
	})
}

// SkipReasonNotIn applies the NotIn predicate on the "skip_reason" field.
func SkipReasonNotIn(vs ...string) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSkipReason), v...))
	})
}

// SkipReasonGT applies the GT predicate on the "skip_reason" field.
func SkipReasonGT(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSkipReason), v))
	})
}

// SkipReasonGTE applies the GTE predicate on the "skip_reason" field.
func SkipReasonGTE(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSkipReason), v))
	})
}

// SkipReasonLT applies the LT predicate on the "skip_reason" field.
func SkipReasonLT(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSkipReason), v))
	})
}

// SkipReasonLTE applies the LTE predicate on the "skip_reason" field.
func SkipReasonLTE(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSkipReason), v))
	})
}

// SkipReasonContains applies the Contains predicate on the "skip_reason" field.
func SkipReasonContains(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldSkipReason), v))
	})
}

// SkipReasonHasPrefix applies the HasPrefix predicate on the "skip_reason" field.
func SkipReasonHasPrefix(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldSkipReason), v))
	})
}

// SkipReasonHasSuffix applies the HasSuffix predicate on the "skip_reason" field.
func SkipReasonHasSuffix(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldSkipReason), v))
	})
}

// SkipReasonIsNil applies the IsNil predicate on the "skip_reason" field.
func SkipReasonIsNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldSkipReason)))
	})
}

// SkipReasonNotNil applies the NotNil predicate on the "skip_reason" field.
func SkipReasonNotNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldSkipReason)))
	})
}

// SkipReasonEqualFold applies the EqualFold predicate on the "skip_reason" field.
func SkipReasonEqualFold(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldSkipReason), v))
	})
}

// SkipReasonContainsFold applies the ContainsFold predicate on the "skip_reason" field.
func SkipReasonContainsFold(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldSkipReason), v))
	})
}

// RepositoryEQ applies the EQ predicate on the "repository" field.
func RepositoryEQ(v Repository) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRepository), v))
	})
}

// RepositoryNEQ applies the NEQ predicate on the "repository" field.
func RepositoryNEQ(v Repository) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRepository), v))
	})
}

// RepositoryIn applies the In predicate on the "repository" field.
func RepositoryIn(vs ...Repository) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldRepository), v...))
	})
}

// RepositoryNotIn applies the NotIn predicate on the "repository" field.
func RepositoryNotIn(vs ...Repository) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldRepository), v...))
	})
}

// MarchEQ applies the EQ predicate on the "march" field.
func MarchEQ(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMarch), v))
	})
}

// MarchNEQ applies the NEQ predicate on the "march" field.
func MarchNEQ(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldMarch), v))
	})
}

// MarchIn applies the In predicate on the "march" field.
func MarchIn(vs ...string) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldMarch), v...))
	})
}

// MarchNotIn applies the NotIn predicate on the "march" field.
func MarchNotIn(vs ...string) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldMarch), v...))
	})
}

// MarchGT applies the GT predicate on the "march" field.
func MarchGT(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldMarch), v))
	})
}

// MarchGTE applies the GTE predicate on the "march" field.
func MarchGTE(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldMarch), v))
	})
}

// MarchLT applies the LT predicate on the "march" field.
func MarchLT(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldMarch), v))
	})
}

// MarchLTE applies the LTE predicate on the "march" field.
func MarchLTE(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldMarch), v))
	})
}

// MarchContains applies the Contains predicate on the "march" field.
func MarchContains(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldMarch), v))
	})
}

// MarchHasPrefix applies the HasPrefix predicate on the "march" field.
func MarchHasPrefix(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldMarch), v))
	})
}

// MarchHasSuffix applies the HasSuffix predicate on the "march" field.
func MarchHasSuffix(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldMarch), v))
	})
}

// MarchEqualFold applies the EqualFold predicate on the "march" field.
func MarchEqualFold(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldMarch), v))
	})
}

// MarchContainsFold applies the ContainsFold predicate on the "march" field.
func MarchContainsFold(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldMarch), v))
	})
}

// VersionEQ applies the EQ predicate on the "version" field.
func VersionEQ(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldVersion), v))
	})
}

// VersionNEQ applies the NEQ predicate on the "version" field.
func VersionNEQ(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldVersion), v))
	})
}

// VersionIn applies the In predicate on the "version" field.
func VersionIn(vs ...string) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldVersion), v...))
	})
}

// VersionNotIn applies the NotIn predicate on the "version" field.
func VersionNotIn(vs ...string) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldVersion), v...))
	})
}

// VersionGT applies the GT predicate on the "version" field.
func VersionGT(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldVersion), v))
	})
}

// VersionGTE applies the GTE predicate on the "version" field.
func VersionGTE(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldVersion), v))
	})
}

// VersionLT applies the LT predicate on the "version" field.
func VersionLT(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldVersion), v))
	})
}

// VersionLTE applies the LTE predicate on the "version" field.
func VersionLTE(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldVersion), v))
	})
}

// VersionContains applies the Contains predicate on the "version" field.
func VersionContains(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldVersion), v))
	})
}

// VersionHasPrefix applies the HasPrefix predicate on the "version" field.
func VersionHasPrefix(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldVersion), v))
	})
}

// VersionHasSuffix applies the HasSuffix predicate on the "version" field.
func VersionHasSuffix(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldVersion), v))
	})
}

// VersionIsNil applies the IsNil predicate on the "version" field.
func VersionIsNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldVersion)))
	})
}

// VersionNotNil applies the NotNil predicate on the "version" field.
func VersionNotNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldVersion)))
	})
}

// VersionEqualFold applies the EqualFold predicate on the "version" field.
func VersionEqualFold(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldVersion), v))
	})
}

// VersionContainsFold applies the ContainsFold predicate on the "version" field.
func VersionContainsFold(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldVersion), v))
	})
}

// RepoVersionEQ applies the EQ predicate on the "repo_version" field.
func RepoVersionEQ(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRepoVersion), v))
	})
}

// RepoVersionNEQ applies the NEQ predicate on the "repo_version" field.
func RepoVersionNEQ(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRepoVersion), v))
	})
}

// RepoVersionIn applies the In predicate on the "repo_version" field.
func RepoVersionIn(vs ...string) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldRepoVersion), v...))
	})
}

// RepoVersionNotIn applies the NotIn predicate on the "repo_version" field.
func RepoVersionNotIn(vs ...string) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldRepoVersion), v...))
	})
}

// RepoVersionGT applies the GT predicate on the "repo_version" field.
func RepoVersionGT(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldRepoVersion), v))
	})
}

// RepoVersionGTE applies the GTE predicate on the "repo_version" field.
func RepoVersionGTE(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldRepoVersion), v))
	})
}

// RepoVersionLT applies the LT predicate on the "repo_version" field.
func RepoVersionLT(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldRepoVersion), v))
	})
}

// RepoVersionLTE applies the LTE predicate on the "repo_version" field.
func RepoVersionLTE(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldRepoVersion), v))
	})
}

// RepoVersionContains applies the Contains predicate on the "repo_version" field.
func RepoVersionContains(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldRepoVersion), v))
	})
}

// RepoVersionHasPrefix applies the HasPrefix predicate on the "repo_version" field.
func RepoVersionHasPrefix(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldRepoVersion), v))
	})
}

// RepoVersionHasSuffix applies the HasSuffix predicate on the "repo_version" field.
func RepoVersionHasSuffix(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldRepoVersion), v))
	})
}

// RepoVersionIsNil applies the IsNil predicate on the "repo_version" field.
func RepoVersionIsNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldRepoVersion)))
	})
}

// RepoVersionNotNil applies the NotNil predicate on the "repo_version" field.
func RepoVersionNotNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldRepoVersion)))
	})
}

// RepoVersionEqualFold applies the EqualFold predicate on the "repo_version" field.
func RepoVersionEqualFold(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldRepoVersion), v))
	})
}

// RepoVersionContainsFold applies the ContainsFold predicate on the "repo_version" field.
func RepoVersionContainsFold(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldRepoVersion), v))
	})
}

// BuildTimeStartEQ applies the EQ predicate on the "build_time_start" field.
func BuildTimeStartEQ(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBuildTimeStart), v))
	})
}

// BuildTimeStartNEQ applies the NEQ predicate on the "build_time_start" field.
func BuildTimeStartNEQ(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldBuildTimeStart), v))
	})
}

// BuildTimeStartIn applies the In predicate on the "build_time_start" field.
func BuildTimeStartIn(vs ...time.Time) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldBuildTimeStart), v...))
	})
}

// BuildTimeStartNotIn applies the NotIn predicate on the "build_time_start" field.
func BuildTimeStartNotIn(vs ...time.Time) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldBuildTimeStart), v...))
	})
}

// BuildTimeStartGT applies the GT predicate on the "build_time_start" field.
func BuildTimeStartGT(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldBuildTimeStart), v))
	})
}

// BuildTimeStartGTE applies the GTE predicate on the "build_time_start" field.
func BuildTimeStartGTE(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldBuildTimeStart), v))
	})
}

// BuildTimeStartLT applies the LT predicate on the "build_time_start" field.
func BuildTimeStartLT(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldBuildTimeStart), v))
	})
}

// BuildTimeStartLTE applies the LTE predicate on the "build_time_start" field.
func BuildTimeStartLTE(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldBuildTimeStart), v))
	})
}

// BuildTimeStartIsNil applies the IsNil predicate on the "build_time_start" field.
func BuildTimeStartIsNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldBuildTimeStart)))
	})
}

// BuildTimeStartNotNil applies the NotNil predicate on the "build_time_start" field.
func BuildTimeStartNotNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldBuildTimeStart)))
	})
}

// BuildTimeEndEQ applies the EQ predicate on the "build_time_end" field.
func BuildTimeEndEQ(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBuildTimeEnd), v))
	})
}

// BuildTimeEndNEQ applies the NEQ predicate on the "build_time_end" field.
func BuildTimeEndNEQ(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldBuildTimeEnd), v))
	})
}

// BuildTimeEndIn applies the In predicate on the "build_time_end" field.
func BuildTimeEndIn(vs ...time.Time) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldBuildTimeEnd), v...))
	})
}

// BuildTimeEndNotIn applies the NotIn predicate on the "build_time_end" field.
func BuildTimeEndNotIn(vs ...time.Time) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldBuildTimeEnd), v...))
	})
}

// BuildTimeEndGT applies the GT predicate on the "build_time_end" field.
func BuildTimeEndGT(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldBuildTimeEnd), v))
	})
}

// BuildTimeEndGTE applies the GTE predicate on the "build_time_end" field.
func BuildTimeEndGTE(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldBuildTimeEnd), v))
	})
}

// BuildTimeEndLT applies the LT predicate on the "build_time_end" field.
func BuildTimeEndLT(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldBuildTimeEnd), v))
	})
}

// BuildTimeEndLTE applies the LTE predicate on the "build_time_end" field.
func BuildTimeEndLTE(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldBuildTimeEnd), v))
	})
}

// BuildTimeEndIsNil applies the IsNil predicate on the "build_time_end" field.
func BuildTimeEndIsNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldBuildTimeEnd)))
	})
}

// BuildTimeEndNotNil applies the NotNil predicate on the "build_time_end" field.
func BuildTimeEndNotNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldBuildTimeEnd)))
	})
}

// UpdatedEQ applies the EQ predicate on the "updated" field.
func UpdatedEQ(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdated), v))
	})
}

// UpdatedNEQ applies the NEQ predicate on the "updated" field.
func UpdatedNEQ(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUpdated), v))
	})
}

// UpdatedIn applies the In predicate on the "updated" field.
func UpdatedIn(vs ...time.Time) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUpdated), v...))
	})
}

// UpdatedNotIn applies the NotIn predicate on the "updated" field.
func UpdatedNotIn(vs ...time.Time) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUpdated), v...))
	})
}

// UpdatedGT applies the GT predicate on the "updated" field.
func UpdatedGT(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUpdated), v))
	})
}

// UpdatedGTE applies the GTE predicate on the "updated" field.
func UpdatedGTE(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUpdated), v))
	})
}

// UpdatedLT applies the LT predicate on the "updated" field.
func UpdatedLT(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUpdated), v))
	})
}

// UpdatedLTE applies the LTE predicate on the "updated" field.
func UpdatedLTE(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUpdated), v))
	})
}

// UpdatedIsNil applies the IsNil predicate on the "updated" field.
func UpdatedIsNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldUpdated)))
	})
}

// UpdatedNotNil applies the NotNil predicate on the "updated" field.
func UpdatedNotNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldUpdated)))
	})
}

// HashEQ applies the EQ predicate on the "hash" field.
func HashEQ(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldHash), v))
	})
}

// HashNEQ applies the NEQ predicate on the "hash" field.
func HashNEQ(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldHash), v))
	})
}

// HashIn applies the In predicate on the "hash" field.
func HashIn(vs ...string) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldHash), v...))
	})
}

// HashNotIn applies the NotIn predicate on the "hash" field.
func HashNotIn(vs ...string) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldHash), v...))
	})
}

// HashGT applies the GT predicate on the "hash" field.
func HashGT(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldHash), v))
	})
}

// HashGTE applies the GTE predicate on the "hash" field.
func HashGTE(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldHash), v))
	})
}

// HashLT applies the LT predicate on the "hash" field.
func HashLT(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldHash), v))
	})
}

// HashLTE applies the LTE predicate on the "hash" field.
func HashLTE(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldHash), v))
	})
}

// HashContains applies the Contains predicate on the "hash" field.
func HashContains(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldHash), v))
	})
}

// HashHasPrefix applies the HasPrefix predicate on the "hash" field.
func HashHasPrefix(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldHash), v))
	})
}

// HashHasSuffix applies the HasSuffix predicate on the "hash" field.
func HashHasSuffix(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldHash), v))
	})
}

// HashIsNil applies the IsNil predicate on the "hash" field.
func HashIsNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldHash)))
	})
}

// HashNotNil applies the NotNil predicate on the "hash" field.
func HashNotNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldHash)))
	})
}

// HashEqualFold applies the EqualFold predicate on the "hash" field.
func HashEqualFold(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldHash), v))
	})
}

// HashContainsFold applies the ContainsFold predicate on the "hash" field.
func HashContainsFold(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldHash), v))
	})
}

// LtoEQ applies the EQ predicate on the "lto" field.
func LtoEQ(v Lto) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLto), v))
	})
}

// LtoNEQ applies the NEQ predicate on the "lto" field.
func LtoNEQ(v Lto) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLto), v))
	})
}

// LtoIn applies the In predicate on the "lto" field.
func LtoIn(vs ...Lto) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLto), v...))
	})
}

// LtoNotIn applies the NotIn predicate on the "lto" field.
func LtoNotIn(vs ...Lto) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLto), v...))
	})
}

// LtoIsNil applies the IsNil predicate on the "lto" field.
func LtoIsNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldLto)))
	})
}

// LtoNotNil applies the NotNil predicate on the "lto" field.
func LtoNotNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldLto)))
	})
}

// LastVersionBuildEQ applies the EQ predicate on the "last_version_build" field.
func LastVersionBuildEQ(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLastVersionBuild), v))
	})
}

// LastVersionBuildNEQ applies the NEQ predicate on the "last_version_build" field.
func LastVersionBuildNEQ(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLastVersionBuild), v))
	})
}

// LastVersionBuildIn applies the In predicate on the "last_version_build" field.
func LastVersionBuildIn(vs ...string) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLastVersionBuild), v...))
	})
}

// LastVersionBuildNotIn applies the NotIn predicate on the "last_version_build" field.
func LastVersionBuildNotIn(vs ...string) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLastVersionBuild), v...))
	})
}

// LastVersionBuildGT applies the GT predicate on the "last_version_build" field.
func LastVersionBuildGT(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLastVersionBuild), v))
	})
}

// LastVersionBuildGTE applies the GTE predicate on the "last_version_build" field.
func LastVersionBuildGTE(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLastVersionBuild), v))
	})
}

// LastVersionBuildLT applies the LT predicate on the "last_version_build" field.
func LastVersionBuildLT(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLastVersionBuild), v))
	})
}

// LastVersionBuildLTE applies the LTE predicate on the "last_version_build" field.
func LastVersionBuildLTE(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLastVersionBuild), v))
	})
}

// LastVersionBuildContains applies the Contains predicate on the "last_version_build" field.
func LastVersionBuildContains(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldLastVersionBuild), v))
	})
}

// LastVersionBuildHasPrefix applies the HasPrefix predicate on the "last_version_build" field.
func LastVersionBuildHasPrefix(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldLastVersionBuild), v))
	})
}

// LastVersionBuildHasSuffix applies the HasSuffix predicate on the "last_version_build" field.
func LastVersionBuildHasSuffix(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldLastVersionBuild), v))
	})
}

// LastVersionBuildIsNil applies the IsNil predicate on the "last_version_build" field.
func LastVersionBuildIsNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldLastVersionBuild)))
	})
}

// LastVersionBuildNotNil applies the NotNil predicate on the "last_version_build" field.
func LastVersionBuildNotNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldLastVersionBuild)))
	})
}

// LastVersionBuildEqualFold applies the EqualFold predicate on the "last_version_build" field.
func LastVersionBuildEqualFold(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldLastVersionBuild), v))
	})
}

// LastVersionBuildContainsFold applies the ContainsFold predicate on the "last_version_build" field.
func LastVersionBuildContainsFold(v string) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldLastVersionBuild), v))
	})
}

// LastVerifiedEQ applies the EQ predicate on the "last_verified" field.
func LastVerifiedEQ(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLastVerified), v))
	})
}

// LastVerifiedNEQ applies the NEQ predicate on the "last_verified" field.
func LastVerifiedNEQ(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLastVerified), v))
	})
}

// LastVerifiedIn applies the In predicate on the "last_verified" field.
func LastVerifiedIn(vs ...time.Time) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLastVerified), v...))
	})
}

// LastVerifiedNotIn applies the NotIn predicate on the "last_verified" field.
func LastVerifiedNotIn(vs ...time.Time) predicate.DbPackage {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DbPackage(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLastVerified), v...))
	})
}

// LastVerifiedGT applies the GT predicate on the "last_verified" field.
func LastVerifiedGT(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLastVerified), v))
	})
}

// LastVerifiedGTE applies the GTE predicate on the "last_verified" field.
func LastVerifiedGTE(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLastVerified), v))
	})
}

// LastVerifiedLT applies the LT predicate on the "last_verified" field.
func LastVerifiedLT(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLastVerified), v))
	})
}

// LastVerifiedLTE applies the LTE predicate on the "last_verified" field.
func LastVerifiedLTE(v time.Time) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLastVerified), v))
	})
}

// LastVerifiedIsNil applies the IsNil predicate on the "last_verified" field.
func LastVerifiedIsNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldLastVerified)))
	})
}

// LastVerifiedNotNil applies the NotNil predicate on the "last_verified" field.
func LastVerifiedNotNil() predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldLastVerified)))
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.DbPackage) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.DbPackage) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.DbPackage) predicate.DbPackage {
	return predicate.DbPackage(func(s *sql.Selector) {
		p(s.Not())
	})
}
