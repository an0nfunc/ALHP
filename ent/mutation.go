// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"git.harting.dev/ALHP/ALHP.GO/ent/dbpackage"
	"git.harting.dev/ALHP/ALHP.GO/ent/predicate"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDbPackage = "DbPackage"
)

// DbPackageMutation represents an operation that mutates the DbPackage nodes in the graph.
type DbPackageMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	pkgbase            *string
	packages           *[]string
	status             *dbpackage.Status
	skip_reason        *string
	repository         *dbpackage.Repository
	march              *string
	version            *string
	repo_version       *string
	build_time_start   *time.Time
	updated            *time.Time
	hash               *string
	lto                *dbpackage.Lto
	last_version_build *string
	last_verified      *time.Time
	debug_symbols      *dbpackage.DebugSymbols
	max_rss            *int64
	addmax_rss         *int64
	u_time             *int64
	addu_time          *int64
	s_time             *int64
	adds_time          *int64
	io_in              *int64
	addio_in           *int64
	io_out             *int64
	addio_out          *int64
	srcinfo            *string
	srcinfo_hash       *string
	pkgbuild           *string
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*DbPackage, error)
	predicates         []predicate.DbPackage
}

var _ ent.Mutation = (*DbPackageMutation)(nil)

// dbpackageOption allows management of the mutation configuration using functional options.
type dbpackageOption func(*DbPackageMutation)

// newDbPackageMutation creates new mutation for the DbPackage entity.
func newDbPackageMutation(c config, op Op, opts ...dbpackageOption) *DbPackageMutation {
	m := &DbPackageMutation{
		config:        c,
		op:            op,
		typ:           TypeDbPackage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDbPackageID sets the ID field of the mutation.
func withDbPackageID(id int) dbpackageOption {
	return func(m *DbPackageMutation) {
		var (
			err   error
			once  sync.Once
			value *DbPackage
		)
		m.oldValue = func(ctx context.Context) (*DbPackage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DbPackage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDbPackage sets the old DbPackage of the mutation.
func withDbPackage(node *DbPackage) dbpackageOption {
	return func(m *DbPackageMutation) {
		m.oldValue = func(context.Context) (*DbPackage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DbPackageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DbPackageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DbPackageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DbPackageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DbPackage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPkgbase sets the "pkgbase" field.
func (m *DbPackageMutation) SetPkgbase(s string) {
	m.pkgbase = &s
}

// Pkgbase returns the value of the "pkgbase" field in the mutation.
func (m *DbPackageMutation) Pkgbase() (r string, exists bool) {
	v := m.pkgbase
	if v == nil {
		return
	}
	return *v, true
}

// OldPkgbase returns the old "pkgbase" field's value of the DbPackage entity.
// If the DbPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbPackageMutation) OldPkgbase(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPkgbase is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPkgbase requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPkgbase: %w", err)
	}
	return oldValue.Pkgbase, nil
}

// ResetPkgbase resets all changes to the "pkgbase" field.
func (m *DbPackageMutation) ResetPkgbase() {
	m.pkgbase = nil
}

// SetPackages sets the "packages" field.
func (m *DbPackageMutation) SetPackages(s []string) {
	m.packages = &s
}

// Packages returns the value of the "packages" field in the mutation.
func (m *DbPackageMutation) Packages() (r []string, exists bool) {
	v := m.packages
	if v == nil {
		return
	}
	return *v, true
}

// OldPackages returns the old "packages" field's value of the DbPackage entity.
// If the DbPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbPackageMutation) OldPackages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackages: %w", err)
	}
	return oldValue.Packages, nil
}

// ClearPackages clears the value of the "packages" field.
func (m *DbPackageMutation) ClearPackages() {
	m.packages = nil
	m.clearedFields[dbpackage.FieldPackages] = struct{}{}
}

// PackagesCleared returns if the "packages" field was cleared in this mutation.
func (m *DbPackageMutation) PackagesCleared() bool {
	_, ok := m.clearedFields[dbpackage.FieldPackages]
	return ok
}

// ResetPackages resets all changes to the "packages" field.
func (m *DbPackageMutation) ResetPackages() {
	m.packages = nil
	delete(m.clearedFields, dbpackage.FieldPackages)
}

// SetStatus sets the "status" field.
func (m *DbPackageMutation) SetStatus(d dbpackage.Status) {
	m.status = &d
}

// Status returns the value of the "status" field in the mutation.
func (m *DbPackageMutation) Status() (r dbpackage.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DbPackage entity.
// If the DbPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbPackageMutation) OldStatus(ctx context.Context) (v dbpackage.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *DbPackageMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[dbpackage.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *DbPackageMutation) StatusCleared() bool {
	_, ok := m.clearedFields[dbpackage.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *DbPackageMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, dbpackage.FieldStatus)
}

// SetSkipReason sets the "skip_reason" field.
func (m *DbPackageMutation) SetSkipReason(s string) {
	m.skip_reason = &s
}

// SkipReason returns the value of the "skip_reason" field in the mutation.
func (m *DbPackageMutation) SkipReason() (r string, exists bool) {
	v := m.skip_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldSkipReason returns the old "skip_reason" field's value of the DbPackage entity.
// If the DbPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbPackageMutation) OldSkipReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkipReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkipReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkipReason: %w", err)
	}
	return oldValue.SkipReason, nil
}

// ClearSkipReason clears the value of the "skip_reason" field.
func (m *DbPackageMutation) ClearSkipReason() {
	m.skip_reason = nil
	m.clearedFields[dbpackage.FieldSkipReason] = struct{}{}
}

// SkipReasonCleared returns if the "skip_reason" field was cleared in this mutation.
func (m *DbPackageMutation) SkipReasonCleared() bool {
	_, ok := m.clearedFields[dbpackage.FieldSkipReason]
	return ok
}

// ResetSkipReason resets all changes to the "skip_reason" field.
func (m *DbPackageMutation) ResetSkipReason() {
	m.skip_reason = nil
	delete(m.clearedFields, dbpackage.FieldSkipReason)
}

// SetRepository sets the "repository" field.
func (m *DbPackageMutation) SetRepository(d dbpackage.Repository) {
	m.repository = &d
}

// Repository returns the value of the "repository" field in the mutation.
func (m *DbPackageMutation) Repository() (r dbpackage.Repository, exists bool) {
	v := m.repository
	if v == nil {
		return
	}
	return *v, true
}

// OldRepository returns the old "repository" field's value of the DbPackage entity.
// If the DbPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbPackageMutation) OldRepository(ctx context.Context) (v dbpackage.Repository, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepository is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepository requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepository: %w", err)
	}
	return oldValue.Repository, nil
}

// ResetRepository resets all changes to the "repository" field.
func (m *DbPackageMutation) ResetRepository() {
	m.repository = nil
}

// SetMarch sets the "march" field.
func (m *DbPackageMutation) SetMarch(s string) {
	m.march = &s
}

// March returns the value of the "march" field in the mutation.
func (m *DbPackageMutation) March() (r string, exists bool) {
	v := m.march
	if v == nil {
		return
	}
	return *v, true
}

// OldMarch returns the old "march" field's value of the DbPackage entity.
// If the DbPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbPackageMutation) OldMarch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMarch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMarch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMarch: %w", err)
	}
	return oldValue.March, nil
}

// ResetMarch resets all changes to the "march" field.
func (m *DbPackageMutation) ResetMarch() {
	m.march = nil
}

// SetVersion sets the "version" field.
func (m *DbPackageMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *DbPackageMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the DbPackage entity.
// If the DbPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbPackageMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *DbPackageMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[dbpackage.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *DbPackageMutation) VersionCleared() bool {
	_, ok := m.clearedFields[dbpackage.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *DbPackageMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, dbpackage.FieldVersion)
}

// SetRepoVersion sets the "repo_version" field.
func (m *DbPackageMutation) SetRepoVersion(s string) {
	m.repo_version = &s
}

// RepoVersion returns the value of the "repo_version" field in the mutation.
func (m *DbPackageMutation) RepoVersion() (r string, exists bool) {
	v := m.repo_version
	if v == nil {
		return
	}
	return *v, true
}

// OldRepoVersion returns the old "repo_version" field's value of the DbPackage entity.
// If the DbPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbPackageMutation) OldRepoVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepoVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepoVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepoVersion: %w", err)
	}
	return oldValue.RepoVersion, nil
}

// ClearRepoVersion clears the value of the "repo_version" field.
func (m *DbPackageMutation) ClearRepoVersion() {
	m.repo_version = nil
	m.clearedFields[dbpackage.FieldRepoVersion] = struct{}{}
}

// RepoVersionCleared returns if the "repo_version" field was cleared in this mutation.
func (m *DbPackageMutation) RepoVersionCleared() bool {
	_, ok := m.clearedFields[dbpackage.FieldRepoVersion]
	return ok
}

// ResetRepoVersion resets all changes to the "repo_version" field.
func (m *DbPackageMutation) ResetRepoVersion() {
	m.repo_version = nil
	delete(m.clearedFields, dbpackage.FieldRepoVersion)
}

// SetBuildTimeStart sets the "build_time_start" field.
func (m *DbPackageMutation) SetBuildTimeStart(t time.Time) {
	m.build_time_start = &t
}

// BuildTimeStart returns the value of the "build_time_start" field in the mutation.
func (m *DbPackageMutation) BuildTimeStart() (r time.Time, exists bool) {
	v := m.build_time_start
	if v == nil {
		return
	}
	return *v, true
}

// OldBuildTimeStart returns the old "build_time_start" field's value of the DbPackage entity.
// If the DbPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbPackageMutation) OldBuildTimeStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuildTimeStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuildTimeStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuildTimeStart: %w", err)
	}
	return oldValue.BuildTimeStart, nil
}

// ClearBuildTimeStart clears the value of the "build_time_start" field.
func (m *DbPackageMutation) ClearBuildTimeStart() {
	m.build_time_start = nil
	m.clearedFields[dbpackage.FieldBuildTimeStart] = struct{}{}
}

// BuildTimeStartCleared returns if the "build_time_start" field was cleared in this mutation.
func (m *DbPackageMutation) BuildTimeStartCleared() bool {
	_, ok := m.clearedFields[dbpackage.FieldBuildTimeStart]
	return ok
}

// ResetBuildTimeStart resets all changes to the "build_time_start" field.
func (m *DbPackageMutation) ResetBuildTimeStart() {
	m.build_time_start = nil
	delete(m.clearedFields, dbpackage.FieldBuildTimeStart)
}

// SetUpdated sets the "updated" field.
func (m *DbPackageMutation) SetUpdated(t time.Time) {
	m.updated = &t
}

// Updated returns the value of the "updated" field in the mutation.
func (m *DbPackageMutation) Updated() (r time.Time, exists bool) {
	v := m.updated
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdated returns the old "updated" field's value of the DbPackage entity.
// If the DbPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbPackageMutation) OldUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdated: %w", err)
	}
	return oldValue.Updated, nil
}

// ClearUpdated clears the value of the "updated" field.
func (m *DbPackageMutation) ClearUpdated() {
	m.updated = nil
	m.clearedFields[dbpackage.FieldUpdated] = struct{}{}
}

// UpdatedCleared returns if the "updated" field was cleared in this mutation.
func (m *DbPackageMutation) UpdatedCleared() bool {
	_, ok := m.clearedFields[dbpackage.FieldUpdated]
	return ok
}

// ResetUpdated resets all changes to the "updated" field.
func (m *DbPackageMutation) ResetUpdated() {
	m.updated = nil
	delete(m.clearedFields, dbpackage.FieldUpdated)
}

// SetHash sets the "hash" field.
func (m *DbPackageMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *DbPackageMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the DbPackage entity.
// If the DbPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbPackageMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ClearHash clears the value of the "hash" field.
func (m *DbPackageMutation) ClearHash() {
	m.hash = nil
	m.clearedFields[dbpackage.FieldHash] = struct{}{}
}

// HashCleared returns if the "hash" field was cleared in this mutation.
func (m *DbPackageMutation) HashCleared() bool {
	_, ok := m.clearedFields[dbpackage.FieldHash]
	return ok
}

// ResetHash resets all changes to the "hash" field.
func (m *DbPackageMutation) ResetHash() {
	m.hash = nil
	delete(m.clearedFields, dbpackage.FieldHash)
}

// SetLto sets the "lto" field.
func (m *DbPackageMutation) SetLto(d dbpackage.Lto) {
	m.lto = &d
}

// Lto returns the value of the "lto" field in the mutation.
func (m *DbPackageMutation) Lto() (r dbpackage.Lto, exists bool) {
	v := m.lto
	if v == nil {
		return
	}
	return *v, true
}

// OldLto returns the old "lto" field's value of the DbPackage entity.
// If the DbPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbPackageMutation) OldLto(ctx context.Context) (v dbpackage.Lto, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLto is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLto requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLto: %w", err)
	}
	return oldValue.Lto, nil
}

// ClearLto clears the value of the "lto" field.
func (m *DbPackageMutation) ClearLto() {
	m.lto = nil
	m.clearedFields[dbpackage.FieldLto] = struct{}{}
}

// LtoCleared returns if the "lto" field was cleared in this mutation.
func (m *DbPackageMutation) LtoCleared() bool {
	_, ok := m.clearedFields[dbpackage.FieldLto]
	return ok
}

// ResetLto resets all changes to the "lto" field.
func (m *DbPackageMutation) ResetLto() {
	m.lto = nil
	delete(m.clearedFields, dbpackage.FieldLto)
}

// SetLastVersionBuild sets the "last_version_build" field.
func (m *DbPackageMutation) SetLastVersionBuild(s string) {
	m.last_version_build = &s
}

// LastVersionBuild returns the value of the "last_version_build" field in the mutation.
func (m *DbPackageMutation) LastVersionBuild() (r string, exists bool) {
	v := m.last_version_build
	if v == nil {
		return
	}
	return *v, true
}

// OldLastVersionBuild returns the old "last_version_build" field's value of the DbPackage entity.
// If the DbPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbPackageMutation) OldLastVersionBuild(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastVersionBuild is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastVersionBuild requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastVersionBuild: %w", err)
	}
	return oldValue.LastVersionBuild, nil
}

// ClearLastVersionBuild clears the value of the "last_version_build" field.
func (m *DbPackageMutation) ClearLastVersionBuild() {
	m.last_version_build = nil
	m.clearedFields[dbpackage.FieldLastVersionBuild] = struct{}{}
}

// LastVersionBuildCleared returns if the "last_version_build" field was cleared in this mutation.
func (m *DbPackageMutation) LastVersionBuildCleared() bool {
	_, ok := m.clearedFields[dbpackage.FieldLastVersionBuild]
	return ok
}

// ResetLastVersionBuild resets all changes to the "last_version_build" field.
func (m *DbPackageMutation) ResetLastVersionBuild() {
	m.last_version_build = nil
	delete(m.clearedFields, dbpackage.FieldLastVersionBuild)
}

// SetLastVerified sets the "last_verified" field.
func (m *DbPackageMutation) SetLastVerified(t time.Time) {
	m.last_verified = &t
}

// LastVerified returns the value of the "last_verified" field in the mutation.
func (m *DbPackageMutation) LastVerified() (r time.Time, exists bool) {
	v := m.last_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldLastVerified returns the old "last_verified" field's value of the DbPackage entity.
// If the DbPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbPackageMutation) OldLastVerified(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastVerified: %w", err)
	}
	return oldValue.LastVerified, nil
}

// ClearLastVerified clears the value of the "last_verified" field.
func (m *DbPackageMutation) ClearLastVerified() {
	m.last_verified = nil
	m.clearedFields[dbpackage.FieldLastVerified] = struct{}{}
}

// LastVerifiedCleared returns if the "last_verified" field was cleared in this mutation.
func (m *DbPackageMutation) LastVerifiedCleared() bool {
	_, ok := m.clearedFields[dbpackage.FieldLastVerified]
	return ok
}

// ResetLastVerified resets all changes to the "last_verified" field.
func (m *DbPackageMutation) ResetLastVerified() {
	m.last_verified = nil
	delete(m.clearedFields, dbpackage.FieldLastVerified)
}

// SetDebugSymbols sets the "debug_symbols" field.
func (m *DbPackageMutation) SetDebugSymbols(ds dbpackage.DebugSymbols) {
	m.debug_symbols = &ds
}

// DebugSymbols returns the value of the "debug_symbols" field in the mutation.
func (m *DbPackageMutation) DebugSymbols() (r dbpackage.DebugSymbols, exists bool) {
	v := m.debug_symbols
	if v == nil {
		return
	}
	return *v, true
}

// OldDebugSymbols returns the old "debug_symbols" field's value of the DbPackage entity.
// If the DbPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbPackageMutation) OldDebugSymbols(ctx context.Context) (v dbpackage.DebugSymbols, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDebugSymbols is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDebugSymbols requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDebugSymbols: %w", err)
	}
	return oldValue.DebugSymbols, nil
}

// ClearDebugSymbols clears the value of the "debug_symbols" field.
func (m *DbPackageMutation) ClearDebugSymbols() {
	m.debug_symbols = nil
	m.clearedFields[dbpackage.FieldDebugSymbols] = struct{}{}
}

// DebugSymbolsCleared returns if the "debug_symbols" field was cleared in this mutation.
func (m *DbPackageMutation) DebugSymbolsCleared() bool {
	_, ok := m.clearedFields[dbpackage.FieldDebugSymbols]
	return ok
}

// ResetDebugSymbols resets all changes to the "debug_symbols" field.
func (m *DbPackageMutation) ResetDebugSymbols() {
	m.debug_symbols = nil
	delete(m.clearedFields, dbpackage.FieldDebugSymbols)
}

// SetMaxRss sets the "max_rss" field.
func (m *DbPackageMutation) SetMaxRss(i int64) {
	m.max_rss = &i
	m.addmax_rss = nil
}

// MaxRss returns the value of the "max_rss" field in the mutation.
func (m *DbPackageMutation) MaxRss() (r int64, exists bool) {
	v := m.max_rss
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxRss returns the old "max_rss" field's value of the DbPackage entity.
// If the DbPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbPackageMutation) OldMaxRss(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxRss is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxRss requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxRss: %w", err)
	}
	return oldValue.MaxRss, nil
}

// AddMaxRss adds i to the "max_rss" field.
func (m *DbPackageMutation) AddMaxRss(i int64) {
	if m.addmax_rss != nil {
		*m.addmax_rss += i
	} else {
		m.addmax_rss = &i
	}
}

// AddedMaxRss returns the value that was added to the "max_rss" field in this mutation.
func (m *DbPackageMutation) AddedMaxRss() (r int64, exists bool) {
	v := m.addmax_rss
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxRss clears the value of the "max_rss" field.
func (m *DbPackageMutation) ClearMaxRss() {
	m.max_rss = nil
	m.addmax_rss = nil
	m.clearedFields[dbpackage.FieldMaxRss] = struct{}{}
}

// MaxRssCleared returns if the "max_rss" field was cleared in this mutation.
func (m *DbPackageMutation) MaxRssCleared() bool {
	_, ok := m.clearedFields[dbpackage.FieldMaxRss]
	return ok
}

// ResetMaxRss resets all changes to the "max_rss" field.
func (m *DbPackageMutation) ResetMaxRss() {
	m.max_rss = nil
	m.addmax_rss = nil
	delete(m.clearedFields, dbpackage.FieldMaxRss)
}

// SetUTime sets the "u_time" field.
func (m *DbPackageMutation) SetUTime(i int64) {
	m.u_time = &i
	m.addu_time = nil
}

// UTime returns the value of the "u_time" field in the mutation.
func (m *DbPackageMutation) UTime() (r int64, exists bool) {
	v := m.u_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUTime returns the old "u_time" field's value of the DbPackage entity.
// If the DbPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbPackageMutation) OldUTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUTime: %w", err)
	}
	return oldValue.UTime, nil
}

// AddUTime adds i to the "u_time" field.
func (m *DbPackageMutation) AddUTime(i int64) {
	if m.addu_time != nil {
		*m.addu_time += i
	} else {
		m.addu_time = &i
	}
}

// AddedUTime returns the value that was added to the "u_time" field in this mutation.
func (m *DbPackageMutation) AddedUTime() (r int64, exists bool) {
	v := m.addu_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearUTime clears the value of the "u_time" field.
func (m *DbPackageMutation) ClearUTime() {
	m.u_time = nil
	m.addu_time = nil
	m.clearedFields[dbpackage.FieldUTime] = struct{}{}
}

// UTimeCleared returns if the "u_time" field was cleared in this mutation.
func (m *DbPackageMutation) UTimeCleared() bool {
	_, ok := m.clearedFields[dbpackage.FieldUTime]
	return ok
}

// ResetUTime resets all changes to the "u_time" field.
func (m *DbPackageMutation) ResetUTime() {
	m.u_time = nil
	m.addu_time = nil
	delete(m.clearedFields, dbpackage.FieldUTime)
}

// SetSTime sets the "s_time" field.
func (m *DbPackageMutation) SetSTime(i int64) {
	m.s_time = &i
	m.adds_time = nil
}

// STime returns the value of the "s_time" field in the mutation.
func (m *DbPackageMutation) STime() (r int64, exists bool) {
	v := m.s_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSTime returns the old "s_time" field's value of the DbPackage entity.
// If the DbPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbPackageMutation) OldSTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSTime: %w", err)
	}
	return oldValue.STime, nil
}

// AddSTime adds i to the "s_time" field.
func (m *DbPackageMutation) AddSTime(i int64) {
	if m.adds_time != nil {
		*m.adds_time += i
	} else {
		m.adds_time = &i
	}
}

// AddedSTime returns the value that was added to the "s_time" field in this mutation.
func (m *DbPackageMutation) AddedSTime() (r int64, exists bool) {
	v := m.adds_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearSTime clears the value of the "s_time" field.
func (m *DbPackageMutation) ClearSTime() {
	m.s_time = nil
	m.adds_time = nil
	m.clearedFields[dbpackage.FieldSTime] = struct{}{}
}

// STimeCleared returns if the "s_time" field was cleared in this mutation.
func (m *DbPackageMutation) STimeCleared() bool {
	_, ok := m.clearedFields[dbpackage.FieldSTime]
	return ok
}

// ResetSTime resets all changes to the "s_time" field.
func (m *DbPackageMutation) ResetSTime() {
	m.s_time = nil
	m.adds_time = nil
	delete(m.clearedFields, dbpackage.FieldSTime)
}

// SetIoIn sets the "io_in" field.
func (m *DbPackageMutation) SetIoIn(i int64) {
	m.io_in = &i
	m.addio_in = nil
}

// IoIn returns the value of the "io_in" field in the mutation.
func (m *DbPackageMutation) IoIn() (r int64, exists bool) {
	v := m.io_in
	if v == nil {
		return
	}
	return *v, true
}

// OldIoIn returns the old "io_in" field's value of the DbPackage entity.
// If the DbPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbPackageMutation) OldIoIn(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIoIn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIoIn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIoIn: %w", err)
	}
	return oldValue.IoIn, nil
}

// AddIoIn adds i to the "io_in" field.
func (m *DbPackageMutation) AddIoIn(i int64) {
	if m.addio_in != nil {
		*m.addio_in += i
	} else {
		m.addio_in = &i
	}
}

// AddedIoIn returns the value that was added to the "io_in" field in this mutation.
func (m *DbPackageMutation) AddedIoIn() (r int64, exists bool) {
	v := m.addio_in
	if v == nil {
		return
	}
	return *v, true
}

// ClearIoIn clears the value of the "io_in" field.
func (m *DbPackageMutation) ClearIoIn() {
	m.io_in = nil
	m.addio_in = nil
	m.clearedFields[dbpackage.FieldIoIn] = struct{}{}
}

// IoInCleared returns if the "io_in" field was cleared in this mutation.
func (m *DbPackageMutation) IoInCleared() bool {
	_, ok := m.clearedFields[dbpackage.FieldIoIn]
	return ok
}

// ResetIoIn resets all changes to the "io_in" field.
func (m *DbPackageMutation) ResetIoIn() {
	m.io_in = nil
	m.addio_in = nil
	delete(m.clearedFields, dbpackage.FieldIoIn)
}

// SetIoOut sets the "io_out" field.
func (m *DbPackageMutation) SetIoOut(i int64) {
	m.io_out = &i
	m.addio_out = nil
}

// IoOut returns the value of the "io_out" field in the mutation.
func (m *DbPackageMutation) IoOut() (r int64, exists bool) {
	v := m.io_out
	if v == nil {
		return
	}
	return *v, true
}

// OldIoOut returns the old "io_out" field's value of the DbPackage entity.
// If the DbPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbPackageMutation) OldIoOut(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIoOut is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIoOut requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIoOut: %w", err)
	}
	return oldValue.IoOut, nil
}

// AddIoOut adds i to the "io_out" field.
func (m *DbPackageMutation) AddIoOut(i int64) {
	if m.addio_out != nil {
		*m.addio_out += i
	} else {
		m.addio_out = &i
	}
}

// AddedIoOut returns the value that was added to the "io_out" field in this mutation.
func (m *DbPackageMutation) AddedIoOut() (r int64, exists bool) {
	v := m.addio_out
	if v == nil {
		return
	}
	return *v, true
}

// ClearIoOut clears the value of the "io_out" field.
func (m *DbPackageMutation) ClearIoOut() {
	m.io_out = nil
	m.addio_out = nil
	m.clearedFields[dbpackage.FieldIoOut] = struct{}{}
}

// IoOutCleared returns if the "io_out" field was cleared in this mutation.
func (m *DbPackageMutation) IoOutCleared() bool {
	_, ok := m.clearedFields[dbpackage.FieldIoOut]
	return ok
}

// ResetIoOut resets all changes to the "io_out" field.
func (m *DbPackageMutation) ResetIoOut() {
	m.io_out = nil
	m.addio_out = nil
	delete(m.clearedFields, dbpackage.FieldIoOut)
}

// SetSrcinfo sets the "srcinfo" field.
func (m *DbPackageMutation) SetSrcinfo(s string) {
	m.srcinfo = &s
}

// Srcinfo returns the value of the "srcinfo" field in the mutation.
func (m *DbPackageMutation) Srcinfo() (r string, exists bool) {
	v := m.srcinfo
	if v == nil {
		return
	}
	return *v, true
}

// OldSrcinfo returns the old "srcinfo" field's value of the DbPackage entity.
// If the DbPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbPackageMutation) OldSrcinfo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSrcinfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSrcinfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSrcinfo: %w", err)
	}
	return oldValue.Srcinfo, nil
}

// ClearSrcinfo clears the value of the "srcinfo" field.
func (m *DbPackageMutation) ClearSrcinfo() {
	m.srcinfo = nil
	m.clearedFields[dbpackage.FieldSrcinfo] = struct{}{}
}

// SrcinfoCleared returns if the "srcinfo" field was cleared in this mutation.
func (m *DbPackageMutation) SrcinfoCleared() bool {
	_, ok := m.clearedFields[dbpackage.FieldSrcinfo]
	return ok
}

// ResetSrcinfo resets all changes to the "srcinfo" field.
func (m *DbPackageMutation) ResetSrcinfo() {
	m.srcinfo = nil
	delete(m.clearedFields, dbpackage.FieldSrcinfo)
}

// SetSrcinfoHash sets the "srcinfo_hash" field.
func (m *DbPackageMutation) SetSrcinfoHash(s string) {
	m.srcinfo_hash = &s
}

// SrcinfoHash returns the value of the "srcinfo_hash" field in the mutation.
func (m *DbPackageMutation) SrcinfoHash() (r string, exists bool) {
	v := m.srcinfo_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldSrcinfoHash returns the old "srcinfo_hash" field's value of the DbPackage entity.
// If the DbPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbPackageMutation) OldSrcinfoHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSrcinfoHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSrcinfoHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSrcinfoHash: %w", err)
	}
	return oldValue.SrcinfoHash, nil
}

// ClearSrcinfoHash clears the value of the "srcinfo_hash" field.
func (m *DbPackageMutation) ClearSrcinfoHash() {
	m.srcinfo_hash = nil
	m.clearedFields[dbpackage.FieldSrcinfoHash] = struct{}{}
}

// SrcinfoHashCleared returns if the "srcinfo_hash" field was cleared in this mutation.
func (m *DbPackageMutation) SrcinfoHashCleared() bool {
	_, ok := m.clearedFields[dbpackage.FieldSrcinfoHash]
	return ok
}

// ResetSrcinfoHash resets all changes to the "srcinfo_hash" field.
func (m *DbPackageMutation) ResetSrcinfoHash() {
	m.srcinfo_hash = nil
	delete(m.clearedFields, dbpackage.FieldSrcinfoHash)
}

// SetPkgbuild sets the "pkgbuild" field.
func (m *DbPackageMutation) SetPkgbuild(s string) {
	m.pkgbuild = &s
}

// Pkgbuild returns the value of the "pkgbuild" field in the mutation.
func (m *DbPackageMutation) Pkgbuild() (r string, exists bool) {
	v := m.pkgbuild
	if v == nil {
		return
	}
	return *v, true
}

// OldPkgbuild returns the old "pkgbuild" field's value of the DbPackage entity.
// If the DbPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbPackageMutation) OldPkgbuild(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPkgbuild is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPkgbuild requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPkgbuild: %w", err)
	}
	return oldValue.Pkgbuild, nil
}

// ClearPkgbuild clears the value of the "pkgbuild" field.
func (m *DbPackageMutation) ClearPkgbuild() {
	m.pkgbuild = nil
	m.clearedFields[dbpackage.FieldPkgbuild] = struct{}{}
}

// PkgbuildCleared returns if the "pkgbuild" field was cleared in this mutation.
func (m *DbPackageMutation) PkgbuildCleared() bool {
	_, ok := m.clearedFields[dbpackage.FieldPkgbuild]
	return ok
}

// ResetPkgbuild resets all changes to the "pkgbuild" field.
func (m *DbPackageMutation) ResetPkgbuild() {
	m.pkgbuild = nil
	delete(m.clearedFields, dbpackage.FieldPkgbuild)
}

// Where appends a list predicates to the DbPackageMutation builder.
func (m *DbPackageMutation) Where(ps ...predicate.DbPackage) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DbPackageMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DbPackage).
func (m *DbPackageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DbPackageMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.pkgbase != nil {
		fields = append(fields, dbpackage.FieldPkgbase)
	}
	if m.packages != nil {
		fields = append(fields, dbpackage.FieldPackages)
	}
	if m.status != nil {
		fields = append(fields, dbpackage.FieldStatus)
	}
	if m.skip_reason != nil {
		fields = append(fields, dbpackage.FieldSkipReason)
	}
	if m.repository != nil {
		fields = append(fields, dbpackage.FieldRepository)
	}
	if m.march != nil {
		fields = append(fields, dbpackage.FieldMarch)
	}
	if m.version != nil {
		fields = append(fields, dbpackage.FieldVersion)
	}
	if m.repo_version != nil {
		fields = append(fields, dbpackage.FieldRepoVersion)
	}
	if m.build_time_start != nil {
		fields = append(fields, dbpackage.FieldBuildTimeStart)
	}
	if m.updated != nil {
		fields = append(fields, dbpackage.FieldUpdated)
	}
	if m.hash != nil {
		fields = append(fields, dbpackage.FieldHash)
	}
	if m.lto != nil {
		fields = append(fields, dbpackage.FieldLto)
	}
	if m.last_version_build != nil {
		fields = append(fields, dbpackage.FieldLastVersionBuild)
	}
	if m.last_verified != nil {
		fields = append(fields, dbpackage.FieldLastVerified)
	}
	if m.debug_symbols != nil {
		fields = append(fields, dbpackage.FieldDebugSymbols)
	}
	if m.max_rss != nil {
		fields = append(fields, dbpackage.FieldMaxRss)
	}
	if m.u_time != nil {
		fields = append(fields, dbpackage.FieldUTime)
	}
	if m.s_time != nil {
		fields = append(fields, dbpackage.FieldSTime)
	}
	if m.io_in != nil {
		fields = append(fields, dbpackage.FieldIoIn)
	}
	if m.io_out != nil {
		fields = append(fields, dbpackage.FieldIoOut)
	}
	if m.srcinfo != nil {
		fields = append(fields, dbpackage.FieldSrcinfo)
	}
	if m.srcinfo_hash != nil {
		fields = append(fields, dbpackage.FieldSrcinfoHash)
	}
	if m.pkgbuild != nil {
		fields = append(fields, dbpackage.FieldPkgbuild)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DbPackageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dbpackage.FieldPkgbase:
		return m.Pkgbase()
	case dbpackage.FieldPackages:
		return m.Packages()
	case dbpackage.FieldStatus:
		return m.Status()
	case dbpackage.FieldSkipReason:
		return m.SkipReason()
	case dbpackage.FieldRepository:
		return m.Repository()
	case dbpackage.FieldMarch:
		return m.March()
	case dbpackage.FieldVersion:
		return m.Version()
	case dbpackage.FieldRepoVersion:
		return m.RepoVersion()
	case dbpackage.FieldBuildTimeStart:
		return m.BuildTimeStart()
	case dbpackage.FieldUpdated:
		return m.Updated()
	case dbpackage.FieldHash:
		return m.Hash()
	case dbpackage.FieldLto:
		return m.Lto()
	case dbpackage.FieldLastVersionBuild:
		return m.LastVersionBuild()
	case dbpackage.FieldLastVerified:
		return m.LastVerified()
	case dbpackage.FieldDebugSymbols:
		return m.DebugSymbols()
	case dbpackage.FieldMaxRss:
		return m.MaxRss()
	case dbpackage.FieldUTime:
		return m.UTime()
	case dbpackage.FieldSTime:
		return m.STime()
	case dbpackage.FieldIoIn:
		return m.IoIn()
	case dbpackage.FieldIoOut:
		return m.IoOut()
	case dbpackage.FieldSrcinfo:
		return m.Srcinfo()
	case dbpackage.FieldSrcinfoHash:
		return m.SrcinfoHash()
	case dbpackage.FieldPkgbuild:
		return m.Pkgbuild()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DbPackageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dbpackage.FieldPkgbase:
		return m.OldPkgbase(ctx)
	case dbpackage.FieldPackages:
		return m.OldPackages(ctx)
	case dbpackage.FieldStatus:
		return m.OldStatus(ctx)
	case dbpackage.FieldSkipReason:
		return m.OldSkipReason(ctx)
	case dbpackage.FieldRepository:
		return m.OldRepository(ctx)
	case dbpackage.FieldMarch:
		return m.OldMarch(ctx)
	case dbpackage.FieldVersion:
		return m.OldVersion(ctx)
	case dbpackage.FieldRepoVersion:
		return m.OldRepoVersion(ctx)
	case dbpackage.FieldBuildTimeStart:
		return m.OldBuildTimeStart(ctx)
	case dbpackage.FieldUpdated:
		return m.OldUpdated(ctx)
	case dbpackage.FieldHash:
		return m.OldHash(ctx)
	case dbpackage.FieldLto:
		return m.OldLto(ctx)
	case dbpackage.FieldLastVersionBuild:
		return m.OldLastVersionBuild(ctx)
	case dbpackage.FieldLastVerified:
		return m.OldLastVerified(ctx)
	case dbpackage.FieldDebugSymbols:
		return m.OldDebugSymbols(ctx)
	case dbpackage.FieldMaxRss:
		return m.OldMaxRss(ctx)
	case dbpackage.FieldUTime:
		return m.OldUTime(ctx)
	case dbpackage.FieldSTime:
		return m.OldSTime(ctx)
	case dbpackage.FieldIoIn:
		return m.OldIoIn(ctx)
	case dbpackage.FieldIoOut:
		return m.OldIoOut(ctx)
	case dbpackage.FieldSrcinfo:
		return m.OldSrcinfo(ctx)
	case dbpackage.FieldSrcinfoHash:
		return m.OldSrcinfoHash(ctx)
	case dbpackage.FieldPkgbuild:
		return m.OldPkgbuild(ctx)
	}
	return nil, fmt.Errorf("unknown DbPackage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DbPackageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dbpackage.FieldPkgbase:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPkgbase(v)
		return nil
	case dbpackage.FieldPackages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackages(v)
		return nil
	case dbpackage.FieldStatus:
		v, ok := value.(dbpackage.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case dbpackage.FieldSkipReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkipReason(v)
		return nil
	case dbpackage.FieldRepository:
		v, ok := value.(dbpackage.Repository)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepository(v)
		return nil
	case dbpackage.FieldMarch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMarch(v)
		return nil
	case dbpackage.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case dbpackage.FieldRepoVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepoVersion(v)
		return nil
	case dbpackage.FieldBuildTimeStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuildTimeStart(v)
		return nil
	case dbpackage.FieldUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdated(v)
		return nil
	case dbpackage.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case dbpackage.FieldLto:
		v, ok := value.(dbpackage.Lto)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLto(v)
		return nil
	case dbpackage.FieldLastVersionBuild:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastVersionBuild(v)
		return nil
	case dbpackage.FieldLastVerified:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastVerified(v)
		return nil
	case dbpackage.FieldDebugSymbols:
		v, ok := value.(dbpackage.DebugSymbols)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDebugSymbols(v)
		return nil
	case dbpackage.FieldMaxRss:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxRss(v)
		return nil
	case dbpackage.FieldUTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUTime(v)
		return nil
	case dbpackage.FieldSTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSTime(v)
		return nil
	case dbpackage.FieldIoIn:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIoIn(v)
		return nil
	case dbpackage.FieldIoOut:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIoOut(v)
		return nil
	case dbpackage.FieldSrcinfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSrcinfo(v)
		return nil
	case dbpackage.FieldSrcinfoHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSrcinfoHash(v)
		return nil
	case dbpackage.FieldPkgbuild:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPkgbuild(v)
		return nil
	}
	return fmt.Errorf("unknown DbPackage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DbPackageMutation) AddedFields() []string {
	var fields []string
	if m.addmax_rss != nil {
		fields = append(fields, dbpackage.FieldMaxRss)
	}
	if m.addu_time != nil {
		fields = append(fields, dbpackage.FieldUTime)
	}
	if m.adds_time != nil {
		fields = append(fields, dbpackage.FieldSTime)
	}
	if m.addio_in != nil {
		fields = append(fields, dbpackage.FieldIoIn)
	}
	if m.addio_out != nil {
		fields = append(fields, dbpackage.FieldIoOut)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DbPackageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dbpackage.FieldMaxRss:
		return m.AddedMaxRss()
	case dbpackage.FieldUTime:
		return m.AddedUTime()
	case dbpackage.FieldSTime:
		return m.AddedSTime()
	case dbpackage.FieldIoIn:
		return m.AddedIoIn()
	case dbpackage.FieldIoOut:
		return m.AddedIoOut()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DbPackageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dbpackage.FieldMaxRss:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxRss(v)
		return nil
	case dbpackage.FieldUTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUTime(v)
		return nil
	case dbpackage.FieldSTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSTime(v)
		return nil
	case dbpackage.FieldIoIn:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIoIn(v)
		return nil
	case dbpackage.FieldIoOut:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIoOut(v)
		return nil
	}
	return fmt.Errorf("unknown DbPackage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DbPackageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dbpackage.FieldPackages) {
		fields = append(fields, dbpackage.FieldPackages)
	}
	if m.FieldCleared(dbpackage.FieldStatus) {
		fields = append(fields, dbpackage.FieldStatus)
	}
	if m.FieldCleared(dbpackage.FieldSkipReason) {
		fields = append(fields, dbpackage.FieldSkipReason)
	}
	if m.FieldCleared(dbpackage.FieldVersion) {
		fields = append(fields, dbpackage.FieldVersion)
	}
	if m.FieldCleared(dbpackage.FieldRepoVersion) {
		fields = append(fields, dbpackage.FieldRepoVersion)
	}
	if m.FieldCleared(dbpackage.FieldBuildTimeStart) {
		fields = append(fields, dbpackage.FieldBuildTimeStart)
	}
	if m.FieldCleared(dbpackage.FieldUpdated) {
		fields = append(fields, dbpackage.FieldUpdated)
	}
	if m.FieldCleared(dbpackage.FieldHash) {
		fields = append(fields, dbpackage.FieldHash)
	}
	if m.FieldCleared(dbpackage.FieldLto) {
		fields = append(fields, dbpackage.FieldLto)
	}
	if m.FieldCleared(dbpackage.FieldLastVersionBuild) {
		fields = append(fields, dbpackage.FieldLastVersionBuild)
	}
	if m.FieldCleared(dbpackage.FieldLastVerified) {
		fields = append(fields, dbpackage.FieldLastVerified)
	}
	if m.FieldCleared(dbpackage.FieldDebugSymbols) {
		fields = append(fields, dbpackage.FieldDebugSymbols)
	}
	if m.FieldCleared(dbpackage.FieldMaxRss) {
		fields = append(fields, dbpackage.FieldMaxRss)
	}
	if m.FieldCleared(dbpackage.FieldUTime) {
		fields = append(fields, dbpackage.FieldUTime)
	}
	if m.FieldCleared(dbpackage.FieldSTime) {
		fields = append(fields, dbpackage.FieldSTime)
	}
	if m.FieldCleared(dbpackage.FieldIoIn) {
		fields = append(fields, dbpackage.FieldIoIn)
	}
	if m.FieldCleared(dbpackage.FieldIoOut) {
		fields = append(fields, dbpackage.FieldIoOut)
	}
	if m.FieldCleared(dbpackage.FieldSrcinfo) {
		fields = append(fields, dbpackage.FieldSrcinfo)
	}
	if m.FieldCleared(dbpackage.FieldSrcinfoHash) {
		fields = append(fields, dbpackage.FieldSrcinfoHash)
	}
	if m.FieldCleared(dbpackage.FieldPkgbuild) {
		fields = append(fields, dbpackage.FieldPkgbuild)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DbPackageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DbPackageMutation) ClearField(name string) error {
	switch name {
	case dbpackage.FieldPackages:
		m.ClearPackages()
		return nil
	case dbpackage.FieldStatus:
		m.ClearStatus()
		return nil
	case dbpackage.FieldSkipReason:
		m.ClearSkipReason()
		return nil
	case dbpackage.FieldVersion:
		m.ClearVersion()
		return nil
	case dbpackage.FieldRepoVersion:
		m.ClearRepoVersion()
		return nil
	case dbpackage.FieldBuildTimeStart:
		m.ClearBuildTimeStart()
		return nil
	case dbpackage.FieldUpdated:
		m.ClearUpdated()
		return nil
	case dbpackage.FieldHash:
		m.ClearHash()
		return nil
	case dbpackage.FieldLto:
		m.ClearLto()
		return nil
	case dbpackage.FieldLastVersionBuild:
		m.ClearLastVersionBuild()
		return nil
	case dbpackage.FieldLastVerified:
		m.ClearLastVerified()
		return nil
	case dbpackage.FieldDebugSymbols:
		m.ClearDebugSymbols()
		return nil
	case dbpackage.FieldMaxRss:
		m.ClearMaxRss()
		return nil
	case dbpackage.FieldUTime:
		m.ClearUTime()
		return nil
	case dbpackage.FieldSTime:
		m.ClearSTime()
		return nil
	case dbpackage.FieldIoIn:
		m.ClearIoIn()
		return nil
	case dbpackage.FieldIoOut:
		m.ClearIoOut()
		return nil
	case dbpackage.FieldSrcinfo:
		m.ClearSrcinfo()
		return nil
	case dbpackage.FieldSrcinfoHash:
		m.ClearSrcinfoHash()
		return nil
	case dbpackage.FieldPkgbuild:
		m.ClearPkgbuild()
		return nil
	}
	return fmt.Errorf("unknown DbPackage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DbPackageMutation) ResetField(name string) error {
	switch name {
	case dbpackage.FieldPkgbase:
		m.ResetPkgbase()
		return nil
	case dbpackage.FieldPackages:
		m.ResetPackages()
		return nil
	case dbpackage.FieldStatus:
		m.ResetStatus()
		return nil
	case dbpackage.FieldSkipReason:
		m.ResetSkipReason()
		return nil
	case dbpackage.FieldRepository:
		m.ResetRepository()
		return nil
	case dbpackage.FieldMarch:
		m.ResetMarch()
		return nil
	case dbpackage.FieldVersion:
		m.ResetVersion()
		return nil
	case dbpackage.FieldRepoVersion:
		m.ResetRepoVersion()
		return nil
	case dbpackage.FieldBuildTimeStart:
		m.ResetBuildTimeStart()
		return nil
	case dbpackage.FieldUpdated:
		m.ResetUpdated()
		return nil
	case dbpackage.FieldHash:
		m.ResetHash()
		return nil
	case dbpackage.FieldLto:
		m.ResetLto()
		return nil
	case dbpackage.FieldLastVersionBuild:
		m.ResetLastVersionBuild()
		return nil
	case dbpackage.FieldLastVerified:
		m.ResetLastVerified()
		return nil
	case dbpackage.FieldDebugSymbols:
		m.ResetDebugSymbols()
		return nil
	case dbpackage.FieldMaxRss:
		m.ResetMaxRss()
		return nil
	case dbpackage.FieldUTime:
		m.ResetUTime()
		return nil
	case dbpackage.FieldSTime:
		m.ResetSTime()
		return nil
	case dbpackage.FieldIoIn:
		m.ResetIoIn()
		return nil
	case dbpackage.FieldIoOut:
		m.ResetIoOut()
		return nil
	case dbpackage.FieldSrcinfo:
		m.ResetSrcinfo()
		return nil
	case dbpackage.FieldSrcinfoHash:
		m.ResetSrcinfoHash()
		return nil
	case dbpackage.FieldPkgbuild:
		m.ResetPkgbuild()
		return nil
	}
	return fmt.Errorf("unknown DbPackage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DbPackageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DbPackageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DbPackageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DbPackageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DbPackageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DbPackageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DbPackageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DbPackage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DbPackageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DbPackage edge %s", name)
}
